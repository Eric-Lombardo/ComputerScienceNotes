# COMP248 Lesson 1 #
## Java ##
- Java was originally designed for programming consumer devices but it's success came from writing internet applets.
- Java is both **safe** and **portable**

## Java Compiler ##
- Java source code is transalted into **byte-code**
- A machine language for a fictious computer called the **JVM**
- **Example**: asking a **translator** to translate english text into french.
- A compiler is a progfram that translates high level instructions into more detailed instructions that can be exceuted by the CPU

## Java Interpreter ##
- Exectutes **JVM**
- Transalted byte-code into machine language and executes it
- Translating byte-code into machine code is relatevily easy comapred to the itnial compilation step
*byte code is already close to machine language*
**Note:** Once compiled to byte-code a Java program can be used on any computer making it very portable

## Flowchart ##
- Java source code (`MyProg.java`) -> *Compiler* -> Java byte code (`MyProg.class`) -> *Interpreter* -> Machine code

## 3 types of errors ##
1. Compile-time (syntax) errors
    - The compiler will find syntax errors and basic problems
    -An executable version of the program is **not** created
2. Run-time errors
    - During a program execution
    - causes programs to terminate abnormally
    - **Example**: Divide by zero
3. Logical (semantic) erros
    - AKA a bug
    - mistake in the algorithm
    - compiler can't catch them
    - the program will run but will give unexpected results
- Compile and Run-time errors are easy to debug
- Logical errors are harder to debug

## Boilerplate for any `.Java` file ##
```
public class ClassName
{
  public static void main(String[] args)
  {
    ...
  }
}
```

## Algorithm ##
- An algorithm is:
    1. unambigous
    2. executable
    3. terminating

## System.out.println ##
- For them example of `System.out.println("blabla")`, the string "blabla" will be printed first **and then** the cursor is placed to the next line

# COMP248 Lesson 2 #
## Comments ##
- Comments can take 3 forms:
1. `//` this commentruns to the end of the line
2. `/* */` the comment runs to the terminating symbol, even across line breaks
3. `/** */` use to make JavaDoc comments

## Indentifiers ##
- The words a programmer uses in a program to name variables, classes and methods
- It can cotnain letters, digits and underscores
- it **can't** have a reserved word (*note: all reserved words are lowercase)
- Limit length ex: numberOfCoffees can be nbOfCoffees
1. ### Guidelines ###  
- Give a significant name
- Avoid using the "$" sign it is reserved for names that are automatically generated by tools
2. ### Conventions ###
- Class names should be titleCase -> `MyClass`
- constants should be uppercase -> `MAXIMUM`
- variables, methods should start with lowercase -> `firstName`

## Indentation ##
- extra white space is ignored
- Programs should be formatted to enhance readability using consostent indentation

## Primative types ##
1. Numeric
    - 4 types of integers: `byte, short, int, long`
    - 2 types to represent floating point numbers (ex: 3.5) `float, double` 
      - floating points are approximate values
2. Characters
    - `char` ex: 'a' 
    - Java uses the unicod3e character set. ASCII is a sub-set of Unicode
3. Boolean
    - `boolean` ex: `true` or `false`
- **Note:** 
    - byte = 1 byte
    - short = 2 byte
    - int - 4 byte
    - long = 8 byte
    - char = 2 byte
    - float = 4 byte
    - double = 8 byte

## Variables ##
- A name for a location in memory
- must be declared before it is used
- indicate variable's name, indicate the type of information it will contain
- Uninitialized variable -> `int total;` 
- Variable declation and initialization -> `int max = 150;` 
- Assignment statement -> `max = 200;`

## Constants ##
- Similar to a variable but can hold only one value while the program is active
- the compiler will cause an error if you try to change the value of a constant during execution
- use the `final` modifierex: `final int MIN_AGE = 18;`

## Scanner ##
- Close the scanner with `scanner.close()`
- good habit to close the scanner object at the end of the main method in your program

## print and println ##
- the "+" if for concatenation
- you need parenthesis for the "+" to be an addition
- example:
```
int x = 1;
int y = 2;
System.out.println("x+y=" + x + y) // "x+y=12"
System.out.println("x+y=" + (x + y)) // "x+y=2"
```
## Operator associativity ##
- A string of assignment operators is grouped right to left
- ex: `n1 = n2 = n3` is evaluated as `n2 = n3` and then `n1 = n2`

## Increment and decrement ##
1. Prefix form: `++count`
    - the variable is inc/dec by 1 **THEN** the new value of the variable is used
2. Postfix form: `count++`
    - the variable is used with it's current value **THEN** the variable is inc/dec by 1
```
s *= --z + y - t;

is equal to:
z = z - 1;
s = s * (z + y - t);

```

## Arithmetic Promotion ##
```
byte -> short and char -> int -> long -> float -> double
```
- **NOTE**: `byte + byte = int` because a byte automatically gets promoted to an integer
- **NOTE**: booleans are not compatible with any type

## Casting ##
- The programmer can explicitly force a type conversion by casting
- syntax: `(desired_type) expression_to_convert`
```
int num;
num = (int) 3.7  //num = 3
```
```
double d;
d = 2 / 4                          //d is 0.0
d = (double) 2 / 4                 //d is 0.5 since the 2 becomes a 2.0
d = (double) (2 / 4)               //d is 0.0 since (2 / 4) is evaluted first at that evaluates to 0
```
- Use parenthesis when casting an arithmetic expression to avoid unwanted results:
```
(int) 1.5 * 1.5   //evaluates to 1.5 and NOT 2.25 or 2
```
because the cast is only being applied to the first value, therefore `1.5` becomes `1` and then `1 * 1.5` is `1.5`

## NextLine ##
- Reads the remainder of the line of text starting where **the last reading left off**
- **Note:** This can cause problems when combining it with different methods for reading from the keyboard such as `nextInt()`
- Example below:
```
1| Scanner scanner = new Scanner(System.in);
2| int n = scanner.nextInt();
3| String s1 = scanner.nextLine();
4| String s2 = scanner.nextLine();
```
if the input was:
```
2
Heads are better than
1 head.
```
the values of n, s1 and s2 would be:
```
n = 2
s1 = ""                          //empty string
s2 = "Heads are better than"
```
To read all 3 lines another `nextLine()` call is needed between line 2 and 3

## Magic Numbers ##
- A magic number is a numeric constant that appears in your code without explanation
```
totalVolume = bottles * 2
```
What does 2 represent (in this case it represents that each bottle holds 2L of liquid) so it's better to create a constant like:
`final double BOTTLE_VOLUME = 2;`

## Format output ##
- `%d` is for digits like `int`
- `%s` is for `strings`
- `%f` is for `floats`
```
%5d   means _ _ _ _ _ (5 spaces)
%5.2f means _ _ . _ _ (5 spaces total including the decimal point. The 2 is the reserved spaces for after the decimal)
```
```
double price = 19.95
System.out.printf("Price:%8.2f", price)
output:
_ _ _19.95


System.out.printf("Price:%.2f", price)
output:
19.95  //no spaces


System.out.printf("Price:%.1f", price)
output:
20.0  
** in this example we are specifying only 1 decimal point but the variable has 2 therefore it would round it instead of just chopping it off **
```

# COMP248 Lesson 3 #
## Flowchart ##
- squares: assignment
- diamond = decision
- parallelagram = input/output
- circles = start/end
- arrows (any direction) = flow control
```
task:
- Prompt for 2 nums
- Read 2 nums
- Add 2 nums
- display Sum
             ______________      _______________     _______________      __________
(start) --> /ask n1 and n2/ --> /read n1 and n2/ --> |sum = n1 + n2| --> /print sum/ --> (end)          
```

## Comparing Floats ##
- Be careful when comparing 2 floating point values (float or double) for equality.
- Do not use `==` *(usually doesn't make sense to use == with flaoting point numbers)*
- floats are approximate
- you want to see if they are "close-enough"
```
if (Math.abs(f1 - f2) < 0.00001)
{
  System.out.print("Essentially equal.");
}
```

## Comapring Strings ##
- To determine if 2 strigns have the same content
```
firstString.equals(secondString);     // returns a boolean
```
- To check if 1 string comes before another based on the Unicode character set
```
firstString.comapreTo(secondString);    // returns an int

--> negative if firstString is BEFORE secondString (Lexicographic aka Dictionary method)
--> positive if firstString is AFTER secondString
--> Zero if the 2 strings have the same content
```
- To determine if 2 strigns have the same cotnent **IGNORING THE CASE**
```
s1.equalsIgnoreCase(s2);
```
- Examples:
```
"aBcd" < "abcd" //syntax error: comparing strings
'aBcd' < 'abcd' //syntax error: not a char
"a" < "b" //syntax error: comapring strings
'a' < 'b' //true
"aBcd".equals("abcd") //false
```

## Lexicographic aka Dictionary method ##
- All uppercase letters come before the lowercase letters. `'Z'` comes before `'a'`
- The space character comes before all printable characters
- Numbers come before letters
- First the letters are comapred, but if they all match and 1 word is longer, than that longer words comes after

## Complete Evaluation ##
- Using `&&` (and) or `||` (or) in Java uses short-circuit
- But using the single `&` and `|` (bitwise) will force Java to evaluate **both** expressions

## Dangling else ##
- An else is matched top the **last unmatched** `if`. No matter what the indentation implies
```
if (condition1)
  if (condition2)
    statement1;
else
  statement2;

THIS IS ACTUALLY

if (condition1)
  if (condition2)
    statement1;
  else
    statement2;
```

## Switch Statement ##
- Aswitch can have an **optional** default case
    - The default case canb be placed anywhere but is usally at the end.
- The values in the case can be `int char String` but floating-points are **not permitted**
- A break exits out of the switch statement. If it is missing it will continue the next statement disregarding the case until it finds the **next break**
```
int category = 10;

switch (category)
{
  case 10:
    sysout.out.print("excellent");
  case 9:
    sysout.out.print("nice");
  case 8:
    sysout.out.print("good");
    break;
}

// This will output "excellentnicegood" because the break is only found in case 8
```

## Logger ##
- Instead of using `System.out.print()` to debug `Logger.getGlobal()` is a way to sysout data but also allows to quickly supppress the logs once you no longer need them

## hasNextInt() ##
- This is to ensure the next input is a number. This will validate inpout to avoid run-time errors that might happen by bad user input

# COMP248 Lesson 4 #
## For-Loops ##
- inside the for-loops we can have multiple expressions
```
// Regular
for (int i = 0; i <= 10; i++>)
{
  doSomething();
}

// Multiple
for (int i = 0, j = 10; i <= 10; i++, j *= 2>)
{
  doSomething();
}
--> Multiple expression for initialization (i=0, j=10). Statements are separated by a comma
--> Multiple expreesion for the increment part (i++ and j*=2)
```

## Do-loop synatx ##
```
do
{
  statements;
}
while (conditon);
```

## Which loop to use ##
- Any loop can be written with another loop
- Use a `while` or a `do` loop when you don't know in advance how many times you want to execute the loop body.

## Break/Continue in a loop ##
- **Break**: Will exit the inner-most loop without evaluating the condition
- **Continue**: Will interrupt the current iteration of the inner-most loop. Will force a new evalaution of the condition for a possible new iteration.

## Exit ##
- **Exit**: While a **break** ends a loop the **exit** will end the entire program. It is invoked with:
```
System.exit(0);
// Takes 1 integer argument
// By tradition a ZERO is used to indicate a normal ending of the program
```